# euler-problem-9
As a heads-up the following write-up is in Greek. It is copied over from the original on Piazza.
Also the code in the [euler_new.c](./euler_new.c) file is an optimization offered in there by a 
[classmate](https://github.com/threadexio) who is also on GitHub and has been uploaded after he has given his permission.

# Building
To build this project from source, you need GCC, some implementation of libc as well as GNU Make.
Enter this directory and run:
```sh
$ make
```

If you wish to use a custom compiler you may also specify that:
```sh
$ make CC=clang # example
```

Same for custom compiler flags(though some default flags are required so proceed with caution):
```sh
$ make CC=clang CFLAGS+=-std=C99 # # example
```

# Write-up

## Απλοποίηση
Μπορούμε να παρατηρήσουμε ότι οι συνθήκες `a < b && b < c` δεν  είναι απαραίτητες διότι οι βρόγχοι εκτελούνται με αύξουσα σειρά.
Αυτό σημαίνει ότι σε κάθε επανάληψη που είναι πιθανό να ισχύουν τα απαιτούμενα κριτήρια, ήδη θα ισχύει a < b < c.
Η εκτέλεση του κώδικα χωρίς τις συνθήκες έχει το ίδιο ακριβώς αποτέλεσμα.
Έτσι ο κώδικας μετατρέπεται στο παρακάτω:
```c
#include <stdio.h>
int main() {
  for (int a = 1; a <= 1000; a++) {
    for (int b = 1; b <= 1000; b++) {
      for (int c = 1; c <= 1000; c++) {
        if (a * a + b * b == c * c && a + b + c == 1000) { // extra conditions removed
          printf("a: %d\nb: %d\nc: %d\n", a, b, c);
          printf("abc:%d\n", a * b * c);
          return 0;
        }
      }
    }
  }
  return -1;
}
```

## But wait, there's more
Η παραπάνω βελτίση μας γλίτωσε λίγα CPU cycles, αλλά ο κύριος ένοχος που καταναλώνει κύκλους δεν ήταν οι συγκρίσεις.
Ας σκεφτούμε λίγο τι γνωρίζουμε για τους αριθμούς a, b και  c.
$a + b + c = 1000$ και $a^2 + b^2 = c^2$.
Αυτά τα ερμηνεύσαμε ως συνθήκες όταν λύναμε το πρόβλημα στην τάξη. Ωστόσο, μπορούμε να τα ερμηνεύσουμε και ως ορισμούς για τους αριθμούς που ψάχνουμε.
ie. Ψάχνουμε εκείνα τα a, b και c για τα οποία ισχύει $a + b + c = 1000$ και $a^2 + b^2 = c^2$.
Σκεφτόμενοι έτσι παρατηρούμε ότι το c  μπορεί να περιοριστεί με την χρήση του πρώτου μέρους του ορισμού:
$a + b + c = 1000 \Rightarrow c = 1000 - a - b$
Στην ουσία μπορούμε λοιπόν να υπολογίσουμε το c για κάθε δεδομένο a και b. Ύστερα μπορούμε να ελέγξουμε απλά αν το  c αυτό ικανοποιεί το δεύτερο μέρος του ορισμού.
Μπορούμε λοιπόν να αποφύγουμε την εσωτερική επανάληψη για την εύρεση του c και να την αντικαταστήσουμε 2 προσθέσεις. Αυτό μπορεί να διαιρέσει τον συνολικό χρόνο εκτέλεσης που προγράμματος κατά 1000.
Εφαρμόζοντας τα παραπάνω προκύπτει ο εξής κώδικας:
```c
#include <stdio.h>
int main() {
  for (int a = 1; a <= 1000; a++) {
    for (int b = 1; b <= 1000; b++) {
      int c = 1000 - a - b; // since a + b + c = 1000, we can define c as a function of a and b
      if (a * a + b * b == c * c) {
        printf("a: %d\nb: %d\nc: %d\n", a, b, c);
        printf("abc:%d\n", a * b * c);
        return 0;
      }
    }
  }
  return -1;
}
```
## So is that all?
Βασικά μπορούμε να μειώσουμε ακόμη περισσότερο τις επαναλήψεις που θα εκτελεστούν. Στην τάξη κάποιος(άφησε ένα σχόλιο παρακάτω για credits αν γίνεται) είχε αναφέρει ότι:
> Αφού a < b και a, b ακέραιοι, δεν μπορούμε να ξεκινήσουμε την εσωτερική επανάληψη με αρχική τιμή του b την a + 1;

Και πράγματι, σαν επιχείρημα στέκει και μειώνει σημαντικά τον αριθμό των επαναλήψεων.
Έτσι από $1000^2$ μπορούμε να κάνουμε την εκτέλεση σε $1000 + 999 + 998 + 997 + ... + 1 = \frac{1000(1000 + 1)}{2}= 500,500$ επαναλήψεις. Αυτές είναι οι μισές από το προηγούμενο βήμα και $\frac{1,000,000,000}{500,500} \approx 2000$ φορές πιο γρήγορα από το αρχικό πρόγραμμα.
Ο κώδικας που προκύπτει είναι ο παρακάτω:
```c
#include <stdio.h>

int main() {
  for (int a = 1; a <= 1000; a++) {
    for (int b = a + 1; b <= 1000; b++) {
      // since a + b + c = 1000, we can define c as a function of a and b
      int c = 1000 - a - b;
      if (a * a + b * b == c * c) {
        printf("a: %d\nb: %d\nc: %d\n", a, b, c);
        printf("abc:%d\n", a * b * c);
        return 0;
      }
    }
  }
  return -1;
}
```

## Surely it can't get any better...
Τελικά μήπως δεν γίνεται καλύτερα;
Σε προβλήματα του Project Euler καλό είναι να θυμόμαστε ότι η συγκεκριμένη σελίδα περιέχει κυρίως μαθηματικά προβλήματα.

### Μαθηματικά
Θα μου πάρει πολύ χρόνο να ξαναγράψω αυτά που έγραψα όταν πρωτοκοίταξα το πρόβλημα. Για να μην σας(και μου) πάρω χρόνο, θα στείλω το PNG που δημιούργησα όταν έλυσα το πρόβλημα.  
Στην ουσία του, έχουμε 3 μεταβλητές και 2 εξισώσεις. Αυτό σημαίνει ότι κατά πάσα πιθανότητα έχουμε 1 βαθμό ελευθερίας, έναν αριθμό από τον οποίο εξαρτώνται οι άλλοι 2. Με λίγες πράξεις χρησιμοποιώντας τον ορισμό των αριθμών μπορούμε εύκολα να δείξουμε ότι το b μπορεί να εκφραστεί συναρτήσει του a και αντίστροφα το  a συναρτήσει του b(παρατηρούμε εξ'αρχής ότι το πρόβλημα είναι συμμετρικό ως προς a και b, ie μπορούμε να αλλάξουμε τις θέσεις των μεταβλητών και θα έχουμε το ίδιο πρόβλημα.
Με τον τρόπο αυτό προκύπτει το παρακάτω:
$b = 1000\frac{500 - a}{1000 - a}, 0 < a < 1000$
$c = 1000 - a - b$
Έτσι το πρόβλημα εύρεσης της μοναδικής πυθαγόρειας τριάδας που να ικανοποιεί τους ορισμούς μας, μετατρέπεται σε πρόβλημα εύρεσης του μοναδικού a για τον οποίο τα b και c που προκύπτουν με τον παραπάνω τρόπο δημιουργούν με αυτό πυθαγόρεια τριάδα.

### C
Χρησιμοποιώντας τα παραπάνω μπορούμε να εξαλήψουμε και τον εσωτερικό βρόχο και να υπολογίσουμε το b και το c με απλές πράξεις(κάτι που είναι υπερβολικά γρήγορο για τους υπολογιστές.
Εφαρμόζοντας τα παραπάνω προκύπτει ο εξής κώδικας:
```c
#include <stdio.h>
int main() {
  for (int a = 1; a < 1000; a++) {
    // mathemagic
    int b = 1000 * (500 - a) / (1000 - a);
    int c = 1000 - a - b;
    if (a * a + b * b == c * c) {
      printf("a: %d, b: %d, c: %d\n", a, b, c);
      printf("abc = %d\n", a * b * c);
      return 0;
    }
  }

  return -1;
}
```
Ο παραπάνω κώδικας, στην χειρότερη περίπτωση εκτελεί 1000 επαναλήψεις. Αυτό σημαίνει ότι είναι περίπου $1,000,000$ φορές πιο γρήγορος από την αρχική μας λύση.
***
## Τhe End
Τέλος αν ενδιαφερόμαστε τόσο πολύ για επίδοση, θα μπορούσαμε να περάσουμε το -Ofast flag στο gcc κατά το compilation προκειμένου να χρησιμοποιήσει διάφορες βελτιώσεις για να επιταχύνει την εκτέλεση του προγράμματος(δεν το δοκίμασα).
